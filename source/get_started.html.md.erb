# Getting Started with Hyperloop

This introduction will take you through most of what you need to know to get started with Hyperloop. There are live code examples, so please feel free to experiment as you read.

There are five important ingredients to the Hyperloop architecture (COMPS for short):

<%= partial "docs/comps_table"%>

This Getting Started guide will introduce you to Hyperloop. After reading this you might like to try some of the [Tutorials](/tutorials) or jump into the [Docs](/docs/architecture) for a comprehensive overview of the Hyperloop architecture.

---------------------------------

<h2><div class="hyperlogoalone" id="components"><%= image_tag "HyperComponents.png", width: '35'%></div>
Components
</h2>

Hyperloop user interfaces are composed of React Components written in Ruby.

Here is the basic structure of a Component:

```ruby
class StrippedBackComponent < React::Component::Base
  render(DIV) do
  end
end
```

As you can see, a Component is just a Ruby class which inherits from `React::Component::Base`. At a minimum, a Component must implement a `render` macro that returns just one HTML element. Under the covers, HyperReact uses Opal to compile this Component into JavaScript then hands it to React to mount as a regular JavaScript React Component.

As with React, there are no templates in Hyperloop, your user interface is made up of Components which mix conditional logic and HTML elements to build the user interface. Unlike React, where you code in JSX and JavaScript, Hyperloop lets you keep all your code in Ruby.

Let's add a little functionality to this Component - you can edit this code if you would like to experiment.

<div class="codemirror-live-edit"
  data-heading="A simple Component rendering a Button"
  data-rows=9
  data-top-level-component="SimpleComponent">
<pre>
class SimpleComponent < React::Component::Base
  render(DIV) do
    BUTTON { 'Push the button' }.on(:click) do
     alert 'You did it!'
    end
  end
end
</pre></div>


There are a few things to notice in the code above.

+ Every Component must have a `render` macro which must return just one HTML element. The syntax of `render(DIV)` is a shorthand for this which will return one div.
+ HTML elements (DIV, BUTTON, etc) can be in uppercase or lowercase.
+ We added an event handler to the button. You can do this for any HTML element in the same way.

### Rendering Components

Hyperloop's architecture encourages you to write simple Components that perform single tasks and render other Components.

```ruby
class App < React::Component::Base
  render(DIV) do
    MainNavigation {}
    PageContents {}
    Footer {}
  end
end
```

This simple approach allows you to build complicated user interfaces yet encapsulate functionality into reusable contained entities.

### Passing parameters

Data is passed downward from a parent Component to its children. There are various techniques for passing data upward and (better still) keeping data in **Stores** independently of Components but we will address that later.

For now, let's experiment with passing parameters:

<div class="codemirror-live-edit"
  data-heading="Passing parameters"
  data-top-level-component="MeeterGreeter">
<pre>
class MeeterGreeter < React::Component::Base
  render(DIV) do
    SayHelloTo(name: "John")
    SayHelloTo(name: "Sally")
  end
end

class SayHelloTo < React::Component::Base
  param :name, type: String

  render(DIV) do
    H4 { "Hello #{params.name}!" }
  end
end
</pre></div>

You will notice a couple of things in the code above:

+ The syntax for adding components is either `MyComponent()` or `MyComponent {}` but never just `MyComponent`. Sometimes you use both - `button(style: default) { "Click Me" }`. Everything in the brackets is passed to the Component as a parameter and everything in the curly brace is rendered within the Component.
+ Parameters can be strongly typed `param :name, type: String` and considering this code will be compiled to JavaScript this is a good idea.

### State and Conditional Execution

One of the greatest things about React is that it encourages you to write code in a declarative way with Components that manage their own state. As state changes, React works out how to render the user interface without you having to worry about the DOM. As state changes, the user interface re-renders itself.

Lets experiment with an example:

<div class="codemirror-live-edit"
  data-heading="Using state"
  data-rows=30
  data-top-level-component="StateExample">
<pre>
class StateExample < React::Component::Base
  define_state show_field: false
  define_state field_value: ""

  render(DIV) do
    show_button
    DIV do
      show_input
      H1 { "#{state.field_value}" }
    end if state.show_field
  end

  def show_button
    BUTTON do
      state.show_field ? "Hide" : "Show"
    end.on(:click) { state.show_field! !state.show_field }
  end

  def show_input
    BR {}
    INPUT(type: :text).on(:change) do |e|
      state.field_value! e.target.value
    end
  end

  def show_text
    H1 { "#{state.field_value}" }
  end
end</pre></div>

A few things to notice in the code above:

+ We define state using the `define_state` macro. Notice how we set the initial value.
+ To reference state we use `state.something` and `state.mutate.something =` (or previously `state.something!`) is used to update state
+ Components are just Ruby classes which have methods.
+ Here is the most important part - notice how React automatically updates the user interface as state changes. This is the very heart of React thinking.

### Stylish Components

Conditional logic, HTML elements, state and style all intermingle in a Hyperloop Component. This website uses Bootstrap CSS, so we have complete access to the Bootstrap CSS from within our Components.

<div class="codemirror-live-edit"
  data-heading="Using CSS"
  data-rows=23
  data-top-level-component="StylishTable">
<pre>
class StylishTable < React::Component::Base
  render(DIV) do
    table.table.table_bordered do
      thead do
        tr do
          th { "First Name" }
          th { "Last Name" }
          th { "Username" }
          th { }
        end
      end
      tbody do
        tr do
          td { "Mark" }
          td { "Otto" }
          td.text_success { "@odm" }
          td { button.btn.btn_primary.btn_sm { "Edit" } }
        end
      end
    end
  end
end</pre></div>

As you can see above, CSS is mixed into HTML elements. `div.something` becomes `<div class="something">`. Also note that `btn-primary` becomes `btn_primary` as '-' is disallowed in Ruby.

### Using JavaScript Libraries

As a final point on Components, it is important to understand that Hyperloop gives you full access to **all JavaScript libraries and components from directly within your Ruby code.** Everything you can do in JavaScript is simple to do in ruby, this includes passing parameters between Ruby and JavaScript and even passing in Ruby lambdas as JavaScript callbacks. All of this magic comes from Opal.

JavaScript components are accessed directly from within your Ruby code. We have a tutorial which will show you exactly how this works.

```ruby
class ExampleComponent < React::Component::Base
  render(DIV) do
    ReactPlayer(url:  'https://www.youtube.com/embed/FzCsDVfPQqk',
      playing: false
    )
  end
end
```

That concludes the introduction to Components. To learn more about Components please see the [Tutorials](/tutorials) and also the comprehensive [Docs](/docs/architecture)

-------------------------------

<h2><div class="hyperlogoalone" id="stores"><%= image_tag "HyperStores.png", width: '35'%></div>
Stores
</h2>

Hyperloop Stores (similar to Flux Stores) exist to hold local application state. Components read state from Stores and render accordingly. This separation of concerns is an improvement in the overall architecture and makes our application easier to maintain.

**Why would we have Stores?** Let's examine that question through an example.

### Overloaded Components

Take the simple Component below which displays an initial discount then gives the user the option of taking a once only 'Lucky Dip' that will either increase or decrease their discount.

<div class="codemirror-live-edit"
  data-heading="An overloaded Component"
  data-rows=15
  data-top-level-component="OfferLuckyDip">
<pre>
class OfferLuckyDip < React::Component::Base
  define_state discount: 30
  define_state lucky_dip_taken: false

  def render
    DIV do
      H1 {"Your discount is #{state.discount}%"}
      BUTTON { "Lucky Dip" }.on(:click) do
        state.discount! (state.discount + rand(-5..5))
        state.lucky_dip_taken! true
      end unless state.lucky_dip_taken
    end
  end
end
</pre></div>

The Component works as expected but there are two fundamental problems with the architecture:

+ Firstly, the discount (state) is tied to the Component itself. This is a problem as we might have other Components on the page which need to also see and interact with the discount. **We need a better place than in our Components to keep application state.**
+ Our business logic (discounts start at 30% and the lucky dip increases or decreases by 5%) is all wrapped up with our presentational code. This makes our application fragile and difficult to evolve. **Our application logic should be separate from our display logic.**

We will fix these problems but first implementing a Hyperloop Store to keep our application state and business logic out of our Components. Later in this guide we will go one step further and move our business logic out of the Store into an Operation but for now the first step will be a big improvement.

### Using Stores

First let's add the Store:

```ruby
class Discounter < Hyperloop::Store
   state discount: 30, scope: :class, reader: true
   state lucky_dip_taken: false, scope: :class, reader: true

  def self.lucky_dip!
    mutate.discount( state.discount + rand(-5..5) )
    mutate.lucky_dip_taken true
  end
end
```

You will notice a few things in the code above:

+ A Store is a ruby class derived from `Hyperloop::Store`
+ We have added two state variables which are both scoped to be class variables meaning that we will only have one instance of this class
+ Similarly the `lucky_dip!` method is a class method
+ Notice how we use `mutate` to change the value of a state variable.

Next we will refactor our Component to use the Store:

```ruby
class OfferLuckyDip < React::Component::Base
  def render
    DIV do
      H1 {"Your discount is #{Discounter.discount}%"}
      BUTTON { "Lucky Dip" }.on(:click) do
        Discounter.lucky_dip!
      end unless Discounter.lucky_dip_taken
    end
  end
end
```

+ Notice that we do not create an instance of the Discounter class but instead access the class methods of the Store `Discounter.lucky_dip!` so that all Components will be using the same 'class instance' of the Store.
+ `Discounter.discount` is a reader class method that was added to the Store for us by `state discount: 30, scope: :class, reader: true` which saved us a lot of typing!
+ Components that read a Store's state will automatically update when the state changes.

Stores can also receive dispatches from Operations - we will come to that later in this overview. In Hyperloop it is perfectly legitimate to interact with a Store through its class methods as we have done above.

That concludes the introduction to Stores. To learn more about Stores please see the [Tutorials](/tutorials) and also the comprehensive [Docs](/docs/architecture)

------------------------------------
<h2><div class="hyperlogoalone" id="models"><%= image_tag "HyperModels.png", width: '35'%></div>
Models
</h2>

Hyperloop Models give your access to your server side Rails ActiveRecord Models from the client. In addition, Hyperloop implements push notifications (via a number of possible technologies) so changes to records on the server are dynamically pushed to all authorized clients.

+ No need for a boilerplate API just to move JSON between the client and server
+ Changes are automatically synchronized between connected clients
+ You do not need to maintain one Model for the server and one Model for the client

**One set of Models used by the client and the server code. Isomorphic Ruby in action.**

Models act like Stores in that they contain state, which is linked to the underlying ActiveRecord Models on the server. Changes make to the server-side Models are pushed to the client depending on the configured Policy for the current user.

### ActiveRecord Models

Our Models are linked to ActiveRecord Models so for this part of the Hyperloop architecture we have a dependancy on Rails and Active Record. If you are not using Rails you can still take advantage of Hyperloop's Components & Stores (which do not depend on Rails) to create stunning interactive user interfaces.

Let's assume we have an ActiveRecord Model called Books:

```ruby
class Book < ApplicationRecord
end
```

### Hyperloop Models

Your ActiveRecord Models are accessible in your client-side code as simply as this:

```ruby
class BookList < React::Component::Base
  render(UL) do
    Book.all.each do |book|
      LI { "#{book.name}" }
    end
  end
end
```

**No boilerplate API, no serialisation, no de-serialisation.** Much like Relay and GraphQL, when rendering, Hyperloop parses through each Component and establishes which fields are necessary then queries just for those fields which are returned as JSON and then inserted into each Component. The key difference with Relay is that both the client and server code is provided by Hyperloop so the entire process is seamless for the developer.

Hyperloop has a few important advantages over Relay and GraphQL:

+ Hyperloop is fully integrated with Rails out the box, so there is no need to build and maintain a GraphQL server or an API.
+ Your server side Models are available to your client side code, so there is no need to recreate an abstracted version of the Models client-side.
+ Unlike Relay and GraphQL, Hyperloop has built in push notifications to magically push changes to underlying server-side Models to any connected client with a Component rendering that Model
+ Access to Models and synchronized changes are controlled neatly by Policy classes
+ Just like Relay and GraphQL, only the records needed to render Components are transferred
+ Everything in beautiful, simple Ruby!

-----------------------------------
<h2><div class="hyperlogoalone" id="operations"><%= image_tag "HyperOperations.png", width: '35'%></div>
Operations
</h2>

In a traditional MCV architecture, there is no defined place to keep business logic. You can overload your Controllers, Views or Models and unless you follow a defined pattern like Trailblazer you generally end up with your business logic all over the place. Our vision of building a 'Complete Ruby Isomorphic Framework' meant that we had to address that problem head on, so we created Operations.

The design of our Operations has been inspired by a few sources:

+ We liked the way the [Mutations Gem](https://github.com/cypriss/mutations) handles parameters and validation
+ [Trailblazer](https://github.com/trailblazer/trailblazer#operation) inspired the idea of Operations and we like the `step` method
+ The [Flux](https://facebook.github.io/flux/) pattern taught us that unidirectional data flow is a good idea and Stores should be able to `receive` dispatches from Operations.

**Operations execute on the clients or the server.** This simple principal radically simplifies application design and testing.

To demonstrate the power of Operations and the various ways in which you can use them, we are going to use three use case example and employ Operations in three different ways:

### Operations and Stores

Firstly we will create a ShoppingCart Store and mutate the Store's data through methods on the Store, much like we did in the Store discount example above, but improved by adding an Operation to the Store's namespace.

Stores hold state and Operations mutate a Store's state. In the Store section above, we demonstrated how a class method on the Store could be used to mutate the state. In this example, we will go one further and add an Operation to the Store's namespace:

```ruby
class ShoppingCart < Hyperloop::Store
  state items: [], scope: :class, reader: true

  class AddItem < Hyperloop::Operation
    validate( !state.items.include?(params.item) )
    step( mutate.items << params.item )
  end
end
```

You will notice in the code above:

+ The AddItem Operation is included in the ShoppingCart Store's namespace. To invoke this Operation would would use `ShoppingCart.AddItem(items: item)`
+ Notice how we validate the incoming params. If `validate` returns falsy then th OPeration

### Dispatchers and Receivers

Next we will write an Operation for login the user out which will dispatch a message that our ShoppingCart will receive. This will be following a Flux pattern.

**All Operations dispatch but it up to a Store to receive a dispatch.** We have implemented the Flux pattern into Operations and Stores. Operations are dispatchers and Stores are receivers.


XXX

### Server Operations

There are some Operations that simply do not make sense to run on the client as (for example) the resources they depend on may not be available on the client. Consider an Operation that needs to send an email - there is no mailer on the client so the Operation has to execute from the server.

That said, with our highest goal being developer productivity, it should be as invisible as possible to the developer where the Operation will execute. To complete the example, a developer writing front-end code should be able to invoke a server-side resource (like a mailer) just as easily as they might invoke a client-side resource.

**ServerOps execute only on the server but are invokable from your Isomorphic code** No need for boilerplate APIs just to execute a server side Operation. ServerOps are just like any normal Operations and invokable from any part of your code.

Finally we will use a server Operation to sign a user up to a mailing list and send them an email. This will show how to use ServerOps and also how `step` works.

XXX



```ruby
class Discounter < Hyperloop::Store
   state discount: 30, scope: :class, reader: true
   state lucky_dip_taken: false, scope: :class, reader: true

  # Note these two lines are essentially "noise" at this point, however
  # they will future proof the API.    They also provide a very clear declaration
  # of the API.  
  class LuckyDip < Hyperloop::Operation; end
  class Bumper < Hyperloop::Operation; end
end

# we can take advantage of the way Ruby deals with classes and close the the
# class definition above as the 'public' interface, and open the class up in another
# file (if we want)

class Discounter

  # likewise because Operations are classes we can open them up here and add implementation:

  class LuckyDip < Hyperloop::Operation
    outbound :dip_or_slip
    validate { !Discounter.lucky_dip_taken }
    fail { puts '**** attempted to take two lucky dips *****' }
    step { params.dip_or_slip = rand(-5..5) }
    # or for more fun we could of course make it a ServerOp and grab the lucky dip based on
    # some global algorithm ensuring the luck dip average across all users 0
  end

  receives LuckyDip do |params|
    mutate.discount( state.discount + params.dip_or_slip )
    mutate.lucky_dip_taken true
  end

  receives Bumper do
    mutate.discount( state.discount * 10 )
  end
end

class OfferLuckyDip < React::Component::Base
  def render
    DIV do
      H1 {"Your discount is #{Discounter.discount}%"}
      BUTTON { "Lucky Dip" }.on(:click) do
        Discounter::LuckyDip.run # note should be able to say Discounter::LuckyDip() but there is a bug :-)
      end unless Discounter.lucky_dip_taken
    end
    BUTTON { "Bump" }.on(:click) do
      Discounter::Bumper.run
    end
  end
end


```

-----------------------------------
<h2><div class="hyperlogoalone" id="policies"><%= image_tag "HyperPolicies.png", width: '35'%></div>
Policies
</h2>

TODO

## Pragmatic Thinking

<%= partial "docs/pragmatic_thinking"%>

------------------------------------
### Welcome aboard!

We hope you have enjoyed this introduction to Hyperloop. As a next step, perhaps try some of the [Tutorials](/tutorials) or jump into the [Docs](/docs/architecture) for a comprehensive overview of the Hyperloop architecture.


# Todo find somewhere for this
+ class MyConfig < Hyperloop
+ class MyComponent < Hyperloop::Component
+ class MyOperation < Hyperloop::Operation
+ class MyModel < Hyperloop::Model
+ class MyPolicy < Hyperloop::Policy
+ class MyStore < Hyperloop::Store
